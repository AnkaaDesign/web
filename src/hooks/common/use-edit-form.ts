// hooks/useEditForm.tsx
import { useEffect, useRef, useCallback } from "react";
import { useForm } from "react-hook-form";
import type { UseFormProps, UseFormReturn, FieldValues, Resolver, DefaultValues } from "react-hook-form";
import _ from "lodash";

interface UseEditFormProps<TFieldValues extends FieldValues = FieldValues, TContext = any, TApiData = any> {
  resolver?: Resolver<TFieldValues, TContext>;
  defaultValues?: DefaultValues<TFieldValues>;
  originalData?: TApiData;
  onSubmit: (data: Partial<TFieldValues>) => Promise<void> | void;
  formOptions?: Omit<UseFormProps<TFieldValues, TContext>, "resolver" | "defaultValues">;
  mapDataToForm?: (apiData: TApiData) => TFieldValues;
  fieldsToOmitIfUnchanged?: (keyof TFieldValues)[];
}

interface UseEditFormReturn<TFieldValues extends FieldValues = FieldValues> extends Omit<UseFormReturn<TFieldValues>, "handleSubmit"> {
  handleSubmit: UseFormReturn<TFieldValues>["handleSubmit"];
  handleSubmitChanges: (onValid?: (data: Partial<TFieldValues>) => unknown, onInvalid?: (errors: any) => unknown) => (e?: React.BaseSyntheticEvent) => Promise<void>;
  reset: UseFormReturn<TFieldValues>["reset"];
  getChangedFields: () => Partial<TFieldValues>;
}

/**
 * Check if a string looks like a real database UUID.
 * UUIDs have format: xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx
 */
function isRealDatabaseId(id: any): boolean {
  if (typeof id !== 'string') return false;
  // UUID v4 pattern (most common for database IDs)
  const uuidPattern = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;
  return uuidPattern.test(id);
}

/**
 * Strip fields that shouldn't affect change detection from array items.
 * - Auto-generated 'id' fields added by useFieldArray (for React keys)
 * - Files that are File objects (they'll be compared separately)
 *
 * IMPORTANT: Real database UUIDs are PRESERVED so the API can identify which records to update.
 * Only auto-generated IDs (like 'cut-initial', 'airbrushing-xxx') are stripped.
 */
function stripAutoGeneratedFields(value: any): any {
  if (Array.isArray(value)) {
    return value.map(item => stripAutoGeneratedFields(item));
  }
  if (value && typeof value === 'object' && !(value instanceof Date) && !(value instanceof File)) {
    const stripped: any = {};
    for (const key of Object.keys(value)) {
      // For 'id' field: only skip if it's auto-generated (not a real database UUID)
      // Real UUIDs are needed by the API to identify which records to update
      if (key === 'id') {
        if (isRealDatabaseId(value[key])) {
          // Keep real database UUIDs
          stripped[key] = value[key];
        }
        // Skip auto-generated IDs (like 'cut-initial', 'airbrushing-xxx', etc.)
        continue;
      }
      // Skip file objects (they're handled separately in submission)
      if (value[key] instanceof File) {
        continue;
      }
      // Skip FileWithPreview-like objects (have uploaded, uploadProgress, etc.)
      if (value[key] && typeof value[key] === 'object' && 'uploaded' in value[key]) {
        continue;
      }
      stripped[key] = stripAutoGeneratedFields(value[key]);
    }
    return stripped;
  }
  return value;
}

/**
 * Check if an item is "empty" (default/placeholder state with no real data).
 * Empty items should be filtered out before comparison.
 */
function isEmptyItem(item: any, fieldName: string): boolean {
  if (!item || typeof item !== 'object') return false;

  // For serviceOrders: empty if no description
  if (fieldName === 'serviceOrders') {
    return !item.description || item.description.trim() === '';
  }

  // For pricing.items: empty if no description (amount can be 0 for courtesy)
  if (fieldName === 'pricing.items') {
    return !item.description || item.description.trim() === '';
  }

  // For cuts: empty if no file, no fileId, and no fileName
  // Note: 'file' objects are stripped by stripAutoGeneratedFields, so we also check 'fileName'
  // which is a string set when a file is selected (won't be stripped)
  if (fieldName === 'cuts') {
    return !item.file && !item.fileId && !item.fileName;
  }

  // For airbrushings: empty if no meaningful data
  // Note: price >= 0 is valid (including 0 for courtesy airbrushings)
  if (fieldName === 'airbrushings') {
    const hasPrice = item.price !== null && item.price !== undefined && Number(item.price) >= 0;
    const hasDates = item.startDate || item.finishDate;
    const hasFiles = (item.receiptFiles?.length > 0) || (item.nfeFiles?.length > 0) || (item.artworkFiles?.length > 0);
    const hasIds = (item.receiptIds?.length > 0) || (item.invoiceIds?.length > 0) || (item.artworkIds?.length > 0);
    // Also check if it's an existing airbrushing (has real UUID id)
    const isExisting = item.id && typeof item.id === 'string' && !item.id.startsWith('airbrushing-');
    return !hasPrice && !hasDates && !hasFiles && !hasIds && !isExisting;
  }

  return false;
}

/**
 * Filter out empty items from an array for comparison purposes.
 */
function filterEmptyItems(value: any, fieldName: string): any {
  if (!Array.isArray(value)) return value;
  return value.filter(item => !isEmptyItem(item, fieldName));
}

/**
 * Deep comparison of values with special handling for dates, arrays, and null/undefined
 * CRITICAL: This function determines if a field has changed. Any edge case not handled
 * will prevent change detection and disable the submit button.
 */
function deepCompare(value1: any, value2: any): boolean {
  // Handle null/undefined/empty string cases - BUT keep "0" as a valid value
  const normalize = (val: any) => {
    // Explicitly handle falsy number values (0, -0) as valid
    if (typeof val === "number") return val;

    // Treat null, undefined, and empty string as null
    if (val === null || val === undefined || val === "") return null;
    if (val === "null" || val === "undefined") return null;
    return val;
  };

  const normalized1 = normalize(value1);
  const normalized2 = normalize(value2);

  // Both are null after normalization
  if (normalized1 === null && normalized2 === null) return true;

  // One is null and the other isn't
  if ((normalized1 === null) !== (normalized2 === null)) return false;

  // Handle dates - compare timestamps with millisecond precision
  if (value1 instanceof Date || value2 instanceof Date) {
    // If one is a Date and the other is not, they're different
    if ((value1 instanceof Date) !== (value2 instanceof Date)) {
      // Try to convert non-Date value to Date for comparison
      try {
        const date1 = value1 instanceof Date ? value1 : new Date(value1);
        const date2 = value2 instanceof Date ? value2 : new Date(value2);

        // Check if both dates are valid
        if (!isNaN(date1.getTime()) && !isNaN(date2.getTime())) {
          return date1.getTime() === date2.getTime();
        }
      } catch {
        return false;
      }
      return false;
    }

    const date1 = value1 as Date;
    const date2 = value2 as Date;

    // Check if both dates are valid
    if (!isNaN(date1.getTime()) && !isNaN(date2.getTime())) {
      return date1.getTime() === date2.getTime();
    }
    return false;
  }

  // Handle arrays - IMPORTANT: Order matters for arrays like services
  if (Array.isArray(value1) && Array.isArray(value2)) {
    if (value1.length !== value2.length) {
      return false;
    }

    // For empty arrays, they're equal
    if (value1.length === 0) return true;

    // For arrays of objects (like services), use lodash for deep comparison
    // This preserves order which is critical for service order detection
    if (value1.length > 0 && typeof value1[0] === "object" && value1[0] !== null) {
      return _.isEqual(value1, value2);
    }

    // For arrays of primitives (like IDs), compare directly
    return _.isEqual(value1, value2);
  }

  // Handle objects (but not arrays or dates)
  if (typeof value1 === "object" && typeof value2 === "object" && value1 !== null && value2 !== null) {
    return _.isEqual(value1, value2);
  }

  // Handle numeric comparisons (0 === "0" should be false)
  if (typeof value1 === "number" || typeof value2 === "number") {
    // Strict type and value comparison for numbers
    if (typeof value1 !== typeof value2) return false;
    return value1 === value2;
  }

  // Primitive comparison
  return normalized1 === normalized2;
}

/**
 * Custom hook to track and submit only fields that have changed in a form
 */
export function useEditForm<TFieldValues extends FieldValues = FieldValues, TContext = any, TApiData = any>({
  resolver,
  defaultValues,
  originalData,
  onSubmit,
  formOptions = {},
  mapDataToForm,
  fieldsToOmitIfUnchanged = [],
}: UseEditFormProps<TFieldValues, TContext, TApiData>): UseEditFormReturn<TFieldValues> {
  const originalRef = useRef<TFieldValues | undefined>(undefined);
  const lastResetData = useRef<TFieldValues | undefined>(undefined);

  const form = useForm<TFieldValues>({
    resolver,
    defaultValues,
    ...formOptions,
  });

  // Update original values when data changes - only on initial mount or when data actually changes
  useEffect(() => {
    if (originalData) {
      const formData = mapDataToForm ? mapDataToForm(originalData) : (originalData as unknown as TFieldValues);

      // Only reset if the data has actually changed (deep comparison)
      if (!_.isEqual(originalRef.current, formData)) {
        // Reset form with new data
        originalRef.current = formData;
        lastResetData.current = formData;
        form.reset(formData as DefaultValues<TFieldValues>);
      }
    }
  }, [originalData, mapDataToForm]); // Removed 'form' from dependencies to avoid circular updates

  // Fields that should have empty items filtered and auto-generated ids stripped
  const arrayFieldsWithEmptyFiltering = ['serviceOrders', 'cuts', 'airbrushings'];

  // Get changed fields
  const getChangedFields = useCallback(() => {
    const formData = form.getValues();
    const original = originalRef.current;

    if (!original) {
      return {} as Partial<TFieldValues>;
    }

    const changedFields: Partial<TFieldValues> = {} as Partial<TFieldValues>;
    const allKeys = new Set([...Object.keys(formData), ...Object.keys(original)]);

    allKeys.forEach((key) => {
      const typedKey = key as keyof TFieldValues;
      let currentValue = formData[typedKey];
      let originalValue = original[typedKey];

      // Special handling for pricing - check nested items
      if (key === 'pricing') {
        const currentPricing = currentValue as any;
        const originalPricing = originalValue as any;

        if (currentPricing && originalPricing) {
          // Strip auto-generated ids and filter empty items from pricing.items
          const currentItems = currentPricing.items || [];
          const originalItems = originalPricing.items || [];

          const filteredCurrentItems = filterEmptyItems(stripAutoGeneratedFields(currentItems), 'pricing.items');
          const filteredOriginalItems = filterEmptyItems(stripAutoGeneratedFields(originalItems), 'pricing.items');

          // Compare the rest of pricing fields
          const strippedCurrent = { ...currentPricing, items: filteredCurrentItems };
          const strippedOriginal = { ...originalPricing, items: filteredOriginalItems };

          if (!_.isEqual(strippedCurrent, strippedOriginal)) {
            // Only include if there are actual changes (not just empty defaults)
            if (filteredCurrentItems.length > 0 || filteredOriginalItems.length > 0) {
              changedFields[typedKey] = { ...currentPricing, items: filteredCurrentItems } as any;
            }
          }
        } else if (currentPricing !== originalPricing) {
          changedFields[typedKey] = currentValue;
        }
        return;
      }

      // For array fields that use useFieldArray, strip auto-generated ids and filter empty items
      if (arrayFieldsWithEmptyFiltering.includes(key) && Array.isArray(currentValue) && Array.isArray(originalValue)) {
        // Strip auto-generated fields (like 'id' from useFieldArray)
        const strippedCurrent = stripAutoGeneratedFields(currentValue);
        const strippedOriginal = stripAutoGeneratedFields(originalValue);

        // Filter out empty items for comparison
        const filteredCurrent = filterEmptyItems(strippedCurrent, key);
        const filteredOriginal = filterEmptyItems(strippedOriginal, key);

        // Compare the filtered/stripped arrays
        if (!_.isEqual(filteredCurrent, filteredOriginal)) {
          // Include the filtered current value (only non-empty items)
          changedFields[typedKey] = filteredCurrent as any;
        }
        return;
      }

      // Skip if field is in omit list and hasn't changed
      if (fieldsToOmitIfUnchanged.includes(typedKey) && deepCompare(currentValue, originalValue)) {
        return;
      }

      // Check if value has changed (for non-array fields)
      const isChanged = !deepCompare(currentValue, originalValue);

      if (isChanged) {
        changedFields[typedKey] = currentValue;
      }
    });

    return changedFields;
  }, [form, fieldsToOmitIfUnchanged]);

  // Handle form submission
  // CRITICAL: We return an async function that captures changedFields BEFORE validation starts.
  // This prevents a race condition where originalData could be updated during async validation,
  // causing getChangedFields() to return {} when called after validation completes.
  const handleSubmitChanges = useCallback((onValid?: (data: Partial<TFieldValues>) => unknown, onInvalid?: (errors: any) => unknown) => {
    return async (e?: React.BaseSyntheticEvent) => {
      // Prevent default form submission immediately
      if (e) {
        e.preventDefault();
        e.stopPropagation();
      }

      // CRITICAL: Capture changed fields NOW, before any async validation
      // This ensures we have the correct snapshot even if originalData changes during validation
      const changedFieldsSnapshot = getChangedFields();

      // Now run validation and submit with the captured snapshot
      try {
        return await form.handleSubmit(async () => {
          // Call onSubmit with the pre-captured changed fields
          const result = await onSubmit(changedFieldsSnapshot);
          if (onValid) onValid(changedFieldsSnapshot);
          return result;
        }, (errors) => {
          if (onInvalid) onInvalid(errors);
        })(e);
      } catch (error) {
        throw error;
      }
    };
  }, [form, getChangedFields, onSubmit]);

  return {
    ...form,
    handleSubmit: form.handleSubmit,
    handleSubmitChanges,
    getChangedFields,
  };
}
